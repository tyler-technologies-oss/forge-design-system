"use strict";(self.webpackChunkforge_design_system=self.webpackChunkforge_design_system||[]).push([[7444],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=a,h=u["".concat(s,".").concat(c)]||u[c]||d[c]||r;return n?o.createElement(h,i(i({ref:t},m),{},{components:n})):o.createElement(h,i({ref:t},m))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},65181:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=n(87462),a=(n(67294),n(3905));const r={title:"Enhanced Angular Integration",decription:"Using Forge components in Angular without CUSTOM_ELEMENTS_SCHEMA.",authors:["mike.matuszak"],tags:["forge","angular","custom-elements","web-components"]},i=void 0,l={permalink:"/blog/2023/03/22/angular-proxies",editUrl:"https://pr.new/github.com/tyler-technologies-oss/forge-design-system/edit/beta/blog/2023-03-22-angular-proxies/index.md",source:"@site/blog/2023-03-22-angular-proxies/index.md",title:"Enhanced Angular Integration",description:"The Angular framework does a \"pretty good\" job of working with Web Components out of the box, but having to use CUSTOMELEMENTSSCHEMA weakens template type-checking overall, can mask errors, and doesn't provide any autocomplete or IntelliSense.  As of v2.1.0 of the @tylertech/forge-angular library, however, released in November 2022, it's no longer necessary to specify the schema, and if you import the associated modules, Forge components can be used as though they were Angular components!",date:"2023-03-22T00:00:00.000Z",formattedDate:"March 22, 2023",tags:[{label:"forge",permalink:"/blog/tags/forge"},{label:"angular",permalink:"/blog/tags/angular"},{label:"custom-elements",permalink:"/blog/tags/custom-elements"},{label:"web-components",permalink:"/blog/tags/web-components"}],readingTime:8.36,hasTruncateMarker:!0,authors:[{name:"Mike Matuszak",title:"Front End Architect",url:"https://github.com/mikematusz",imageURL:"https://github.com/mikematusz.png",key:"mike.matuszak"}],frontMatter:{title:"Enhanced Angular Integration",decription:"Using Forge components in Angular without CUSTOM_ELEMENTS_SCHEMA.",authors:["mike.matuszak"],tags:["forge","angular","custom-elements","web-components"]},prevItem:{title:"Adopting Container Queries",permalink:"/blog/2023/05/05/adopting-container-queries"},nextItem:{title:"Split View Component",permalink:"/blog/2023/02/10/split-view-component"}},s={authorsImageUrls:[void 0]},p=[{value:"Proxy Components",id:"proxy-components",level:2},{value:"Application Usage",id:"application-usage",level:2},{value:"Generating the Proxy Components",id:"generating-the-proxy-components",level:2},{value:"The Custom Elements Manifest",id:"the-custom-elements-manifest",level:2}],m={toc:p};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'The Angular framework does a "pretty good" job of working with Web Components out of the box, but having to use ',(0,a.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA")," weakens template type-checking overall, can mask errors, and doesn't provide any autocomplete or IntelliSense.  As of v2.1.0 of the ",(0,a.kt)("inlineCode",{parentName:"p"},"@tylertech/forge-angular")," library, however, released in November 2022, it's no longer necessary to specify the schema, and if you import the associated modules, Forge components can be used as though they were Angular components!"),(0,a.kt)("h2",{id:"proxy-components"},"Proxy Components"),(0,a.kt)("p",null,"There are a few moving parts, but the piece that actually enables the integration are Angular ",(0,a.kt)("inlineCode",{parentName:"p"},"@Component()")," definitions that mirror the Forge Web Components without introducing any new DOM elements, which we're calling Proxy Components.  They provide just enough definition for Angular to recognize the component, and then do everything they can to get out of the way.  These components are all generated, so they can be more automatically kept up to date.  We'll get into more detail about how that works later on in this post.  Here's a simple example of a proxy component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  selector: 'forge-radio',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: '<ng-content></ng-content>'\n})\nexport class RadioComponent {\n\n    /** Gets/sets whether the radio button is dense. */\n    @Input()\n    public set dense(value: RadioComponentCustomElement['dense'] | string) {\n        this.zone.runOutsideAngular(() => {\n            this.elementRef.nativeElement.dense = value != null && `${value}` !== 'false';\n        });\n    }\n\n    public get dense(): RadioComponentCustomElement['dense'] {\n        return this.elementRef.nativeElement.dense;\n    }\n\n\n    public syncCheckedState(...args: Parameters<RadioComponentCustomElement['syncCheckedState']>): ReturnType<RadioComponentCustomElement['syncCheckedState']> {\n        return this.zone.runOutsideAngular(() => this.elementRef.nativeElement.syncCheckedState(...args));\n    }\n\n    constructor(\n        changeDetectorRef: ChangeDetectorRef,\n        protected elementRef: ElementRef<RadioComponentCustomElement>,\n        protected zone: NgZone\n    ) {\n        defineRadioComponent();\n        changeDetectorRef.detach();\n    }\n}\n")),(0,a.kt)("p",null,"As you can see by the selector, the Forge web component itself ",(0,a.kt)("em",{parentName:"p"},"is")," the Angular component.  It has an ",(0,a.kt)("inlineCode",{parentName:"p"},"@Input()")," for each public property of the Forge component, and a public method for each public method of the component.  And that's basically it.  It mirrors the types directly from the Forge type definitions, along with any JSDoc, and minimizes Angular's footprint by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"runOutsideAngular")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"changeDetectorRef.detach()")," along with ",(0,a.kt)("inlineCode",{parentName:"p"},"onPush")," change detection."),(0,a.kt)("p",null,"Note also the boolean coercion for the ",(0,a.kt)("inlineCode",{parentName:"p"},"density")," property, so that ",(0,a.kt)("inlineCode",{parentName:"p"},'dense="true"')," or even just ",(0,a.kt)("inlineCode",{parentName:"p"},"dense")," still works and you don't need ",(0,a.kt)("inlineCode",{parentName:"p"},'[dense]="true"'),". The intention is that a template that was valid with ",(0,a.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA")," should also work without it using the proxy components."),(0,a.kt)("p",null,"You may wonder why there aren't any ",(0,a.kt)("inlineCode",{parentName:"p"},"@Output()")," properties, but they're actually not necessary at all because the Forge library provides typings for ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElementEventMap"),".  This means that they're already strongly typed and support auto-suggest, and since Angular has built-in support for native events, it's better to treat them as such because it supports bubbling.  The way Forge was already working was optimal, so we didn't want the proxy components to get in the way."),(0,a.kt)("p",null,"Lastly, the component constructor invokes the ",(0,a.kt)("inlineCode",{parentName:"p"},"defineRadioComponent()")," method, removing the need to call that explicitly in the application.  In the most recent version, this is also done in the module constructor, to account for components that are rendered dynamically, e.g. by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"document.createElement('forge-button')"),".  Prior to v2.5.0, that would still require the application to ensure the custom element is defined.  We have also added these ",(0,a.kt)("inlineCode",{parentName:"p"},"define")," calls to singleton services that show Forge components, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"DialogService")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ToastService"),"."),(0,a.kt)("h2",{id:"application-usage"},"Application Usage"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"A summary of the process is also noted in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tyler-technologies-oss/forge-angular/releases/tag/v2.1.0"},"Forge v2.1.0 release notes")," and ",(0,a.kt)("a",{parentName:"p",href:"https://forge.tylerdev.io/main/?path=/docs/guides-framework-usage--page"},"Framework Usage Guide")," on Storybook.")),(0,a.kt)("p",null,"Ideally, you should be able to import the necessary modules for components in your templates (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeRadioModule"),"), remove ",(0,a.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"define***Element()")," calls, and it will just work.  Or if there are any compilation errors, they'll represent actual issues with the correctness of the template.  As we've rolled this out in a number of apps, it has certainly turned up a number of very real defects that were obscured by ",(0,a.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA"),", but for the most part required very few changes.  The most common case where stricter typing caused a problem was providing an object to a boolean property, essentially using whether it was defined to determine truthiness, which can be coerced using ",(0,a.kt)("inlineCode",{parentName:"p"},"!!"),".  Angular also allows the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"$any()")," to override usages that may not satisfy TypeScript, but you know are correct and want to defer or avoid changing them at the current time."),(0,a.kt)("p",null,"The easiest way to do this is usually to go module-by-module, remove ",(0,a.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA"),", and import the modules for each Forge web component used in the templates of components until they compile.  Then remove the ",(0,a.kt)("inlineCode",{parentName:"p"},"define***Element()")," calls."),(0,a.kt)("p",null,"In Forge 2.0 we decided to make this entirely opt-in, to prevent upgrading a minor version of the ",(0,a.kt)("inlineCode",{parentName:"p"},"forge-angular")," from behaving like a breaking change with stricter type-checking.  So, where the ",(0,a.kt)("inlineCode",{parentName:"p"},"forge-angular")," library already provides modules for value accesor directives, for now you'll need to import a separate ",(0,a.kt)("inlineCode",{parentName:"p"},"Forge*ProxyModule")," for those components.  In the future, most likley Forge 3.0, we intend to combine these so you get both the Proxy Component and value accesor in the same module."),(0,a.kt)("p",null,"Also, as much as possible, we've tried to roll up components that are always used together into the parent module.  For example, if you import ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeListModule"),", it will provide proxy components for both ",(0,a.kt)("inlineCode",{parentName:"p"},"<forge-list>")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"<forge-list-item>"),".  This is purely intended as a conveninence, and ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeListItemModule")," still exists independently."),(0,a.kt)("p",null,"There is also a ",(0,a.kt)("inlineCode",{parentName:"p"},"ProxyComponentsModule")," that includes all proxy components, similar to how ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeModule")," contains all the value accessor modules.  Importing individual modules will provide better tree-shaking and is preferred, but if you were already using the roll-up module this will provide a similar experience in cases where the optimization isn't necessary."),(0,a.kt)("p",null,"Consider the following template from the ",(0,a.kt)("inlineCode",{parentName:"p"},"forge-angular")," demo app, which will not need to change at all.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<forge-button type="raised">\n    <button id="tooltip-demo-btn">Hover me</button>\n</forge-button>\n<forge-tooltip #tooltip target="#tooltip-demo-btn" [text]="text" [position]="position" [delay]="delay"></forge-tooltip>\n<forge-text-field>\n    <input type="text" id="tooltip-text" [(ngModel)]="text" />\n    <label for="tooltip-text">Text</label>\n</forge-text-field>\n<forge-text-field>\n    <input type="number" id="tooltip-delay" [(ngModel)]="delay" />\n    <label for="tooltip-delay">Delay (ms)</label>\n</forge-text-field>\n<forge-select id="tooltip-position" label="Position" [(ngModel)]="position">\n    <forge-option value="top">Top</forge-option>\n    <forge-option value="right">Right</forge-option>\n    <forge-option value="bottom">Bottom</forge-option>\n    <forge-option value="left">Left</forge-option>\n</forge-select>\n<forge-checkbox>\n    <input id="tooltip-builder" type="checkbox" [(ngModel)]="useBuilder" (change)="onUseBuilderChanged($event)" />\n    <label for="tooltip-builder">Use Builder</label>\n</forge-checkbox>\n<forge-tooltip delay="500" text="Provides a builder function to render an HTML element in the tooltip instead of just text."></forge-tooltip>\n')),(0,a.kt)("p",null,"The original module file called ",(0,a.kt)("inlineCode",{parentName:"p"},"define")," for each component, specified ",(0,a.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA")," and also was using the ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeSelectModule")," for the ",(0,a.kt)("inlineCode",{parentName:"p"},"[(ngModel)]")," binding on the ",(0,a.kt)("inlineCode",{parentName:"p"},"<forge-select>")," element."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"defineButtonComponent();\ndefineTooltipComponent();\ndefineTextFieldComponent();\ndefineCheckboxComponent();\ndefineSelectComponent();\n\n@NgModule({\n  declarations: [TooltipComponent],\n  imports: [\n    CommonModule,\n    TooltipRoutingModule,\n    FormsModule,\n    SharedModule,\n    ForgeSelectModule\n  ],\n  schemas: [CUSTOM_ELEMENTS_SCHEMA]\n})\nexport class TooltipModule { }\n")),(0,a.kt)("p",null,"This was changed to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@NgModule({\n  declarations: [TooltipComponent],\n  imports: [\n    CommonModule,\n    TooltipRoutingModule,\n    FormsModule,\n    SharedModule,\n    ForgeButtonModule,\n    ForgeCheckboxModule,\n    ForgeSelectModule,\n    ForgeSelectProxyModule,\n    ForgeTextFieldModule,\n    ForgeTooltipModule\n  ]\n})\nexport class TooltipModule { }\n")),(0,a.kt)("p",null,"Note that we had to import both ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeSelectModule")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeSelectProxyModule"),", and also that we did not need to import ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeOptionModule")," for the ",(0,a.kt)("inlineCode",{parentName:"p"},"<forge-option>")," usages because the ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeSelectModule")," already re-exports that."),(0,a.kt)("h2",{id:"generating-the-proxy-components"},"Generating the Proxy Components"),(0,a.kt)("p",null,"In order to ensure the components could be kept up to date with the latest changes in Forge with minimal effort, the components are generated using the Angular Schematics in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tyler-technologies-oss/forge-schematics"},(0,a.kt)("inlineCode",{parentName:"a"},"forge-schematics"))," repository.  For the most part, the process of updating ",(0,a.kt)("inlineCode",{parentName:"p"},"forge-angular")," to reflect changes in ",(0,a.kt)("inlineCode",{parentName:"p"},"forge")," is just:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"npm i @tylertech/forge@latest\nnpm run generate-proxies\n")),(0,a.kt)("p",null,"This will update existing components, generate proxy components for any new ones added (such as the recent ",(0,a.kt)("inlineCode",{parentName:"p"},"forge-split-view"),") and even create modules where they don't exist.  For new components, it's currently still a manual process to update ",(0,a.kt)("inlineCode",{parentName:"p"},"index.ts")," files and add them to ",(0,a.kt)("inlineCode",{parentName:"p"},"ProxyComponentsModule"),".  It may also be desirable to add a demo to the app in order to exercise the types and showcase their usage.  Eventually we may automate the creation of a PR when new versions of Forge are published."),(0,a.kt)("p",null,"If you want to add an additional relationship to have one component's module export another as a convenience, such as only needing to import ",(0,a.kt)("inlineCode",{parentName:"p"},"ForgeSplitViewModule")," and also be able to automatically use ",(0,a.kt)("inlineCode",{parentName:"p"},"forge-split-view-panel")," in your template, these can be configured in the ",(0,a.kt)("inlineCode",{parentName:"p"},"generate-proxies.json")," file, before running the above command, by adding to ",(0,a.kt)("inlineCode",{parentName:"p"},"componentDependencies"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "manifest": "node_modules/@tylertech/forge/custom-elements.json",\n    "importPath": "@tylertech/forge",\n    "exclude": "",\n    "outDir": "projects/forge-angular/src/lib",\n    "outDirExcludePrefix": "forge-",\n    "modulePrefix": "Forge",\n    "useDefineFunction": true,\n    "componentDependencies": {\n        "forge-accordion": ["forge-expansion-panel"],\n        "forge-button-toggle-group": ["forge-button-toggle"],\n        "forge-chip-field": ["forge-chip"],\n        "forge-chip-set": ["forge-chip"],\n        "forge-expansion-panel": ["forge-open-icon"],\n        "forge-icon-button": ["forge-icon"],\n        "forge-list": ["forge-list-item"],\n        "forge-select": ["forge-option"],\n        "forge-split-view": ["forge-split-view-panel"],\n        "forge-stepper": ["forge-step"],\n        "forge-tab-bar": ["forge-tab"],\n        "forge-view-switcher": ["forge-view"]\n    }\n}\n')),(0,a.kt)("p",null,"As you can see from the configuration options, the schematic itself is fairly generic, and may work with other Web Component libraries besides Forge.  It does assume certain conventions are followed, such as the use of TypeScript and specifically ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElementEventMap")," typings, but could probably be modified with additional options if the need ever arose.  The most essential metadata the schematic relies on, however, is a JSON file now published by the Forge library known as a Custom Elements Manifest."),(0,a.kt)("h2",{id:"the-custom-elements-manifest"},"The Custom Elements Manifest"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/webcomponents/custom-elements-manifest"},"Custom Elements Manifest")," represents an effort to standardize on a common, machine-readable specification to describe custom elements. The schema is written in TypeScript and compiled to JSON Schema."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/webcomponents/custom-elements-manifest#framework-integration"},"Framework Integration")," is a documented use case for consuming such a manifest. The example cited is automating the creation of wrapper components for React, but here we're using it for Angular.  This schema could also be used to generate documentation of attributes, slots, events, and other features of Web Components in Storybook or the Forge website that currently require a lot of manual effort to keep up to date.  There's also an existing plugin for the analyzer for creating React wrappers based on the manifest, which might be of interest to React developers here at Tyler."),(0,a.kt)("p",null,"The manifest is automatically generated as part of the build using the ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@custom-elements-manifest/analyzer"},(0,a.kt)("inlineCode",{parentName:"a"},"@custom-elements-manifest/analyzer"))," and included in the published npm package."),(0,a.kt)("p",null,"For the Angular component generation to work, the only requirement is that the tag name for each custom element be specified in the JSDoc for the component class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * The custom element class behind the `<forge-radio>` element.\n * \n * @tag forge-radio\n */\n@CustomElement({ name: RADIO_CONSTANTS.elementName })\nexport class RadioComponent extends BaseComponent implements IRadioComponent {...}\n")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://custom-elements-manifest.open-wc.org/analyzer/getting-started/#supported-jsdoc"},"Other JSDoc tags")," exist for including metadata about slots, attributes, CSS Shadow Parts, CSS Custom Properties, events, and more.  Specifying these properties could be useful for generating documentation or perhaps even surfacing them to developers in their code editor."))}d.isMDXComponent=!0}}]);